Selection Sort: PUT SMALLEST NUMBER AT FRONT OF ARRAY
- iterate through the entire array
    - then, pick the first index as location of min index
    - iterate through rest of array, find location of smallest value
    - swap the two (first location picked, actual smallest value index)
    - repeat

Insertion Sort: ITERATE THROUGH, PUT EACH VALUE INTO PROPER SORTED SPOT ON LEFT ARRAY
- starting at index 1 (not 0).. we are saying that a[0] is our array of sorted numbers
---> it is of length one so obviously it is sorted
- then we are picking the next number (a[i]) and putting it into place in the sorted part
of the array with a while loop by using a[j + 1]  = a[j];

Merge Sort: DIVIDE IN HALF, SORT EACH HALF BY DIVIDG IN HALM, ON RETURN MERGE THOSE TWO HALVES BY PICKING SMALLEST VALUE FROM EACH HALF
- each time it is called, it calls itself again with the bottom half of the array, and the top half of the array
- then it goes and merges those two halves
--->it has two different arrays, and it goes through and says if val at left array < val right array
then adds that val to temp array, and keeps checking and comparing back and forth between the two arrays
then adds those to values to temp, which is returned back and up stack since it is the end of the function

Quick Sort: PICK A PIVOT, MAKE ALL NUMBERS TO LEFT LESS THAN PIVOT, ALL NUMBERS TO THE RIGHT BE GREATER THAN PIVOT
pick a pivot and then partition left and right sub arrays such that all elements in left are < elements in right
then call again for those sub arrays, which sorts them

how to partition the array: choose an element from the array as pivot
move all elements < pivot to left, all elements > pivot to right
