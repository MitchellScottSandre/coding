Characters

char c;
treated as a n integer, signed integer of just 8 bits (1 byte)
the integer can be a code that represents printable and non-printing characters

ASCII --> American standard code for information interchange, 7 bit code, 8th bit can be used for parity

char c = 'a'; // 97
int i = 'a';
c = '0';//number 40
c = '\0'; //null
c += 9;

Strings:
- represented by an array of chars, terminated by the null character
char s[] = "hello"; // local array variable h e l l o \0
SAME AS
char s[] = {h, e, l,l,o};
char *t = "hello"; //string literal, t points to hello, stored in data segment
const char *t = "hello";


Constant Type Qualifier
- indicates that something will not be modified (treat it as read-only); gives you error if you try to change it
- assignment to a const objects results in error
- eg const int i = 10;//initializer, not an assignment
i = 5// error
what about a point to a const object?
const int *p;//cannot assign to a dereferenced pointer to const
p = &i;//okay
*p = 5;//ERROR

int *q;
q = p;//not a compile error, gives you a warning
q = (int *)p;//no warning, no error, but dubious
*q = 5;

- const pointer (not as common)
int * const r;
r = q;//error


String library;
char str1[10], str2[10];
str1 = "abc";//compile error, incompatible types
if (str1 == str2) always return false

#include <string.h>
size_t strlen(const char*s); //returns length of string, minus the null characater
char *strcpy (char *s0, const char *s1); // s1 is being copied into s0, the storage in s0 must be big enough though
char *strncpy (char *s0, const char *s1, size_t n);//copy up to n characters from s1 into s0
char *strcat (Char *s0, const char *s1);
int strcmp (const char (s0, const char *s1);//compares two strings "lexicographically", dictionary order ..... abc < def, ab < abc <0 means s0 < s1; > 0 mens s0 > s1, == 0 means s0 = =s1


"Fix" concatentation to allocate to a new string

#include <assert.h>
#include <strlib.h>
#include <string.h>


char *concat(const char *s0, cont char *s1){
	char *s = malloc( (strlen(s0) + strlen(s1) + 1)* sizeof(char));//adds size of char null to end (for null)
	strcpy(s, s0);
	strcat(s, s1);
	return s;
}

int main (void){
	char *hi = concat("hello", "world");
	printf("%s\n", hi);//helloworld should be the output.
	free(hi);
	return 0;
}


aside

int printf(const char *format,...);

char str[] = "ab%dc";
difference between printf("%s", str); printf(str); // first would print %d, second would be looking for an integer since %d
