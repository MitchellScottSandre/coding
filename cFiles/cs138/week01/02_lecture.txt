Character Strings in CS 138
- even experienced programmers routinely make mistakes in their manipulation
- <string> library ; well engineered, they have worked out the bugs, use it and you won't have bugs

#include <string>
string s;

Some useful bits of the string API
+
==, <=, <,
s.length() //number of chars in s
s.at(i) //checks the access (SAFE, SLOW)
s[i]    //unchecked access (NOT SAFE, fast)
s.c_str() //returns the c-style char* equivalent of s
s.substr(i, n); //substring of n characters starting at index i
s.substr(i) //substring started at index i and ending at the end of s
s.find(str, pos) //returns first index of str in s starting at or after pos, RETUNRS -1 if string NOT FOUND,
--->technically it returns string::npos
s.rfind(str, pos) //returns last index of str in s starting at or before pos
s.replace() replace char within s
s.insert() //insert it in s

s[x] returns a CHAR, if you add two chars together you add TWO INTS together

=====================================================================================================================

Character vs string
'a' vs "a"
- 'a' is a single character, char, represented internally as  a one byte integer
- "a" is a string value of length 1.
--> it is an instance of the class string, it takes more storage than a single integer
----> for this course don't worry about the storage cost of using a string

error example:
cout << "m" + "g" << endl; //c++ converts this to a char* because it assumes you probably meant to work in c

therefore, to add two strings with + use
cout << (string)"m" + (string)"g" << end;

What Java Got Wrong:
//java code
String s = "Hello";
String t = "Hello";
if (s == t){
 //not clear if s and t will have the same address
}
//supposed to use this
if (s.equals(t)){

}

Back In C ++
we can use s == t since it checks the strings character by character

Accessing Command Line Arguments: argc, argv

int main (int argc, char* argv[]){
//stuff
}

g++ -o myprog myprog.c
//argc is 3 since
./myprog -flurble blat //what the hell is flurble plat
//myprog is going to be in argv 0
//-flurble is going to be in argv 1
//blat is goign to be in argv 2


=====================================================================================================================

Simple Input and Output:

- much simpler than c and java
- #include <iostream> gets you three useful streams
	cin, cout, cerr
- Use these operators: << for output and >> for input
	- work with numbers, chars, and strings
- use endl to flush the output and END THE line

Very nicely formatted output is <iomanip>


Input White Space:
string foo, bar;

=================== CIN ================
cin >> foo >> bar; //grabs the next two tokens in the input stream, skipping all intermediate WHITE spaces
//skip all the boring stuff, only grab the important stuff
WHEN IN A LOOP WITH CIN:
after the last read that was successful, the character in the string is right after the last non white space character
the next character, could be new line, end of file, a space,
important: THE MARKER DOEST GET TO THE END OF FILE UNTIL YOU CALL IT ONCE MORE!!!!
NEED TO CALL IT ONCE MORE TO GET TO THE END


Variable Length Input and EOF (End of File):
sometimes, you want to do a task of variable number of times
	- read a bunch of numbers, find the average
1. count the number of items ahed of time, put that number of front of input file (awkward)
2. use a dummy/sentinel "impossible value" that indicated it was the last one (-1, DUMMY, FRODO_THE_ELF)
3. let the language and run-time do the work for you!
	- good news, in C__ is that this is taken care of for you magically by the run time, you just have to
	check if the eof flag has been raised for your input stream

SO, to check EOF
check if cin.eof() or (even better), cin.fail() returns true
Both eo() and fail() can be used with other input streams, too

eof() and fail() don't return true until you go one step TOO FAR

while (cin >> next){//while, this thing evaluates to true. 1. cin attempts to input next, if it fails then it returns FALSE
	sum += next;
	count++;
}

//what happens on line 109:
1. attemopted read which may trigger eof then
2. checking if cin is still valid

if we enter 123abc
int n;
cin >> 123abc puts the 123 into n
string s;
cin >> 123abc puts the entire things ??? TEST THIS
===================  end of CIN ================

=================== get line ================
To read a line at a time (with white space left instact)
do this;
string line;
getline(cin, line);
line.find().... to parse the input stringthe NL char is removed from the input stream but NOT stored in the variable line
getline works with other kinds of input streams too, not just cin

=================== end of get line ================


Redirecting standard IO Streams
g++ -o myprog myprog.cc

./myprog
//enter input directly, output shows up on screen

//copy from phone

=====================================================================================================================


FILE INPUT AND OUTPUT
- there are library classes ifstream and ofstream that you



What, exactly, are cin, cout, cerr?
- they are just plain old global variables that are defined by the C++ standard library

void printAnswer(ostream &output, string word){

}

=====================================================================================================================

C++ Arrays:
- C++ arrays are almost exactly the same as in C
- must state max size ("extent") up front and must be a compile time constant
- const int, or explicit number, BUT NOT A VARIABLE
int A[15];//okay
const int N = 5;
int B[N];// okay
int M;
cin >> M;
int C[M];//ILLEGAL, but some compilers allow it

remember that a[i] means address of a[0] + i * element_size;
a[i] == a + i == i + a == i[a]

The vector<T> class

Accessing Vector Elements:
