Lecture 5
Review: Static and Dynamic Memory Allocation

  Memory for your variables come from either
  1. Run-time stack handles automated allocation of storage for params and local variables as procedures are called
    - Disappears automatically at the end of the proccall
    - Balloon b;
  2. Freestore (aka the heap) handles all programmatic requests for storage via new (for C++ objects/structs, bus also ints etc.) and malloc (and relatives, in C)
    - user must return this storage when done via free/delete (for languages that do not have garbage collection)
    - if you see something New, you should delete that New
    - pointer p I on the stack, the object it points to is on the heap
    - Ballon *p = new Balloon;


Example:

    #include <iostream>
    #include <string>
    #include <cassert>

    struct Node {
      int value;
      Node* next;
    };

    int main .... {
      Node stackNode; //made in the stack
      stackNode.value = 99;
      stackNode.next = nullptr;
      Node *pHeapNode = new Node; //pointer to a node. made in HEAP
      pHeapNode->value = 15;
      pHeapNode->next = &stackNode;
      cout << pHeapNode->value << " " << stackNode.value << endl;
      cout << pHeapNode <<  endl;//outputs address
      cout << pHeapNode->next << endl;
      cout << &stackNode < <endl;
    }

    //output
    //15 99
    //0x7fb1b0.... // 0x means hex value, its a big value, and you shouldnt print this//out


Swapping Example

    void swap1(int x, int y){
      int temp = x;
      x = y;
      y = temp;
    }

    void swap2(int *px, int *py){
      const int temp = *px;//value of px, deference it
      *px = *py;
      *py = temp;
    }

    main (int argc, char *argv[]){
      int x = 5;
      int y = 3;
      swap1 (x, y);
      swap2(&x, &y);
      cout << x << " " << y << endl;
    }

Linked List Stuff:

    #include <iostream>
    #include <string>
    using namespace std;


    struct Node {
      string val;
      Node *next;
    };

    int main (int argc, char *argv[]){
      Node *p = new Node;
      p->val = "first";
      p->next = nullptr;
      Node *q, r; //q is pointer, r is not
      r.val = "flurble";
      q = new Node;
      q->next = p;
      q->val = "second";
      Node *s;
      s = new Node;
      s->val = "third";
      s->next = q;
      Node *temp = s;
      while (temp != nullptr){
        cout << temp->val << endl;
        temp = temp->next;
      }
      delete p;//clean up!
      delete q;
      delete s;
      //DONT DLETE R THO
    }


Introducing the Linked List:

    struct Node {
      string val;
      //other stuff too maybe
      Node *next;
    }

    int main (int argc, char *argv[]){
      Node *first = new Node;
    }


I Missed a Slide……

Introducing ADTs

- an abstract data type (ADT) is a mathematical structure that has a well defined and widely recognizable behaviour
  - it contains data that may be accessed only in a prescribed manner, by a set of named operations
  - Each operation has
    - A signature, which describes the params and the type of the returned value
    - a pre condition (logic statement) that specifies what is assumed to be true before the operation may be applied
    - a post condition (logic statement) that described the value or affect of the operation

Some Examples of ADTs:

- a vector / sequence is an ordered data container that allows random access to individual elements, but usually allows adds/deletes only at the end
- a stack is an ORDERED data container with a LIFO (last in first out) policy
- QUEUE is FIFO (first in first out)
- a set is an unordered data container that can contain a given element at most once
- a multi set is zero, one, or more times
- A dictionary / map is an unordered data container of pairs
- if (alb) and (a, c) are in M, then b == c ***
- can do a lookup based on the first “key element
- a multi map is like a map, except that *** is not assumed
- The C++ standard Library has implementations of these and many more besides!
  - And boost.org provides even more cutting-edge C++ libraries

ADTs are ABSTRACT

- There may be multiple ways to implement a given ADT, but the abstract meaning is the same regardless
  - that is, the abstract specification of, example, a stack, is the same
  - this point is important!!!!
- often, a programming language will supply means to create a heard interface around the ADT
  - an interface enforces a limited access of clients to the internal details, which the clients should not be touching directly
  - ex: interface of Stack supports push and pop operations, but not at
  - C++/Java/C# provide strong language-level support for building interfaces via class definitions

Style of ADTs

- initially, we are going to use a functional programming style to create our ADTs in a C ish C++
  - this is aclean mathematically, but sometimes inefficient if done naively due to needless parameter copying
- general format of an ADT operation in this style is:
  - newADT operationName (oldADT, otherParams)

The STACK ADT: a little more formally

- initStack (no args), creates and returns a new empty stack to the caller
- push takes stack s and an element eNew and return a new stack that’s identical to S
- TO DO FILL IN MORE OF THIS

Pre and Post Conditions:

- these are statements of logic that involve the parameters

initStack: →stack

  - pre: true
  - Post: returned value is a new empty stack

isEmpty : stack→boolean

  Pre:true
  Post: return value is same as N==0

push: stack X element → stack

  pre: (stack exists, take as given); true
  Post: old stack in same order + new one.. order is eNew.. e1…e2….e3…

pop: stack → stack

  Pre: !isEmpty()
  Post: old stack, except without the top…. new :….. e2….e3…..

peek: stack → element

  Pre: !isEmpty()
  Post: returned vape is e1

nuke: stack→ stack

  Pre: true
  Post: returned value is an empty stack; old nodes deleted; old storage returned

Implementing a Stack as a Linked List:

- first Interesting design question:
  - what data type (parameter/return type) should we use to model a stack that is implemented as a linked list
- Recall our linked list from the other day
- ….


    #include <cassert>
    Node * initStack(){
      return nullptr;
    }

    Node * push (Node *first, string val){
      Node *newNode = new Node;
      newNode -> val = val;
      newNode -> next = first;
      return newNode;
    }

    bool isEmpty (Node * first){
      return nullptr == first;
    }

    String peek(Node *first){
      assert(!isEmpty(first));
      return first->val;
    }

    Node * pop (Node * first){
      assert(!isEmpty(first));
      Node * temp = first->next;
      delete first;
      return p;
    }
