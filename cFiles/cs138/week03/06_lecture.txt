Why Don't We get ...

Stack Interface vs Implementation:
- take a good look at the interface of the various stack operations, and ignore the code for a minute
	- it is possible to understand how to use a stack by simply studying the interface (if there is enough detail specified by the comments)
	- th actual details of the implementation do not matter to the client uch as long as they do the job correctly
	- we will see how we might implement a stack diferently while still using the same interface
	- later we will sue an OO style to change the syntax slightly but preserving the ideas

	- So on to the VECTOR-based approach
		- yes, we will talk about efficiency and parameter copying afterwards

Complexity of Stack Operations
LinkedList Implementation:
	push, pop, peek, nuke

VectorList Implementation:


SE Teachable Moment: Adapters
	- you might say to yourself
	- vector class does a good job for me, why don't I just always use THINGS
	- Answer is: when you design an ADT for use by others, the interface is the most important part
	- maybe you don't want all of these other implementations (that vetor gives) available for the client
	- just give them a stack that gives them exactly what they need


An Adapter:
- the stack implemented by a vector is an example of what's called an adapter
- the stack ADT has a small, well understood API, push, pop, ...
	- but vector has lots of other functionality stacks really do not need!!

	//FILL IN MORE


Bondage and Discipline:
- everything ought to be free (libretarian), shouldn't have to obey rules
- but in engineering, we like discipline

Information Hiding:
- expose the interface (what they need to use it efficiently)
- stuff that is unlikely to change is stuff that belongs in interface


Reference Parameters:
- C/Java Support: Call by Value (you make copies of the parameters), memory allocated on Stack
	- real overhead cost if parameter is a big entity, like an object that contains many sub objects
	- only the return value, if any, is copied back
	it would be really nice to allow changes to parameters to propagate back to the calling environment?

	WE CAN IN C++ and C#

Reference Parameters:
	just put an & after the type, int& x, int &y, any changes I made to the variable will occur to the caller too
	changing the variable in the calling environment
	Acts like a pointer, but use it as though it were the variable itself

	These are the NORM in C++
	This is super USEFUL


const& parameters
- const reference parameter is a reference parameter that you cannot change, not allowed to do so

Reference Parameters vs Pointers:
//more notes here
