Review: Reference Parameters
- C/Java support CALL BY VALUE
	Stack pop (Stack s){
	}
	- new copy is made of each variable passed as a parameter to a function; this can be expensive if they are big vectors
	- change made to the parameter affect only the new local variable; do not propagate back to calling environment
	- this is the DEFAULT approach in C++

- C++/C# Support call by reference (also call by value)
	void pop(Stack &s){}
	bool isEmpty(const Stack &s){}
	-changes made to a reference parameter inside a procedure DO propagate back to the calling environment
	- Use a const reference parameter when you want to be able to JUST use the VALUE of the object
	- preferred approach in C++

//TO DO: look online at list of example functions that use reference parameters

//TO DO: look online at Main program as with Linked Lists with Ref Params

============================================================================================================================================

3 Kinds of Variables you Meet in C++
	- Global Variables:
		- are defined outside of any enclosing function/class/struct
		- usage is frowned upon

	- Local Variables
		- are defined within a function/method body
		- they come into existence when the function is classed, and die when the function terminates

	-Member/Instance Variables, are a sup part of a larger variables that is an instance of a struct or class
		- created when instance is created, die when instance dies

============================================================================================================================================

Scopes of Identifiers and ARs:

	- in C,C++, an identifier (a name you picked, for a variable or procedure) is visible from its declaration until the end of the CURRENT SCOPE, which could be the:
		- end of current {} block
		- end of a procedure body
		- end of loop/if/switch
		- global variables are visible globally

	- As your program exectues, scopes are entered and exited
	- When a new scope is entered, an activation record (AR, area of storage on the run-time stack, also called a STACK FRAME) is created for it
		- ARs contain storage for parameters, the eventual return value (if any), and local variables PLIT is remember the location of where the call was made from in the calling aenvironment
		- when a variable declaration is encountered, space for that variable is created in the current AR
