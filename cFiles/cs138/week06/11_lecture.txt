 Trees:
	- special kind of graph
	- if the tree is non-empty, there is a single special node called the ROOT
	- each node may have zero or more CHILDREN
	- there root node has no PARENT; every other node has exactly one parent
	- there can be no cycles in the underlying undirected graph

	Facts about trees:
	- typically, we direct edges from the parent to the child node
	- must be fully connected (no orphan nodes or clusters)
	- for any node, there is a unique path to it from the root

	- the "top" node is the root; its the only node with no parent
		- when we program, we typically use a special pointer to point to the root node, like the first element of a list
		- so nullptr == root means the tree has no elements
	- a node with no children is called a leaf
	- non-leaves are called internal nodes
	- the HEIGHT of a node is the length of the longest path from it down to a leaf
		- the height of a tree is the height of the root
	- the DEPTH of a node is the length of the path from the root to it

=========================================================================================================

Binary Trees:
- a binary tree, each node has at MOST TWO children
- usually call them the left and right child
- the binary search tree is one kind of a binary tree
- the heap is also a king of binary tree, but it is not a BST as the ordering property of it is different

Binary Search Tree:
- each node has a "key" value (that can be compared by <)
	- we assume no duplicate keys for now
- each node can have up to two children (left and right)
- the BST PROPERTY holds for every node in the tree:
	- the keys of all nodes in the left subtree (if any) are < my key
	- the keys of all nodes in the right subtree (if any) are > my key
- the following is NOT the BST Property:
	- at each node left.key < key < right.key
	- this is logically weaker than the BST property

BST Operations:
- we are going to examine LOOKUP, INSERT, PRINT, and DELETE on BSTs
- assume keys are STRINGS
- assume some other data called otherstuff

BSTs all the way down:
- the BST property holds at every node in the entire tree
- this means that if you pick an arbitrary node, the subtree with that node as root is also a BST
	- this is important, as it means we can use recursion to implement most of our routines
	- also, when we change a BST, we need worry only that the changes preserve the BST property; unchanged subtrees should still be ok

BST lookup:
- in a sorted linked list, we start at the first element
- in a BST, we start at the root
	- but if we do not find what we are looking for, where do we go next?

HAS vs LOOKUP
- in real applications, LOOKUP is more useful than HAS
	- usually we want to return rest of info associated with that key, not just to check if it is there

Insertion into a BST:
	- keep looking until nullptr, basically, except we insert a new node where the nullptr was and make the parent point to the new node

General BST Operations:
- usually use recursion
- first check if tree is empty
- if not empty, consider the current node, and depending on what it is then consider checking the left/right nodes

BST Structure:
- for any given data set, there may be many possible BSTs

BST Print:
- start at root, we want to print in ALPHABETICAL order, this:
	- everything in the left subtree needs to be printed before the root
	- and everything in the right subtree needs to be printed after the root

Print and Inorder Traversal
- BEST_print's implementation uses a well-known algorithm for iterating through nodes of a binary tree (not necessarily a BST)
- it's called an INORDER traversal
- while you can trace through the execution carefully using a stack model as we have done before, there's a cool trick for tracing inorder tree traversals:
	- when you encounter a LEAF node (first + only time), perform the op
		- in this case, operation == print the key value
	- the SECOND time you encounter an internal node, perform the operation

=========================================================================================================

Iterative vs Recursive:
- some problems can be solved both iteratively and recursively; which is better?
- recursive solutions are often more mathematically elegant, as is the case with the BST operations we are looking at
	- often, when presented with a nice recursive solution, it looks "obvious", but it might be pretty hard to design from scratch
- iterative solutions have a kind of "comfortable" cognitive appeal to many
	- all of the work is done in front of you (you can see all of it in a loop)
	- before (older days) iterative solutions were preferred, as overhead of recursion sometimes caused performances issues
	- BUT today, with modern day compilers, this is not a significant problem


- iterative solution to BST_print (for fun, only) DO NOT USE

void iterativeBSTPrint (const BST& root) { stack<BST> nodeStack; // BST is Node*
    Node *cur = root;
    while (true) {
        if (nullptr != cur) {
            nodeStack.push(cur);
            cur = cur->left;
        } else if (nodeStack.size() == 0) {
            return;
        } else {
            cur = nodeStack.peek();
            nodeStack.pop();
            cout << "    \"" << cur->key << "\""
                    << endl;
            cur = cur->right;
	}
}

Complexity of BST Operations
- assume there are N nodes in the tree
- print is ... what
	- O (N) since all nodes are visited and printer once
- lookup/insert
	- best case, when it is a balanced tree, ______
	- worst case, k is a key that is not present, k + 1 for a key that's not present
	- k is roughly log2(n) if the tree is balanced

Deleting from a BST:
- requires a little thought
	- must preserve the BST property after deletion
	- can't just delete a node, what about the children?
	- in later courses, will juggle and rebalance the tree
- here's a non-invasive idea:
	- add a boolean "zombie" flag to each NodeChunk
	- set to false initially and set to true upon "deletion"
	- zombie nodes are not printed and are not compared to keys during insert / lookup except for navigation
	- advantage: simple
	- disadvantage: works OK for short term, or if only for a few deletes, but performance degrades as size of tree increases
	- DO NOT DO THIS

SOOOO
- assume we have found the node we want to delete, call it the TARGET NODE, and that we have access to its parent's like to it
- the hard part is going to be setting the target's parent to point to something reasonable, and making sure the new tree is really a BST
- let's consider the 3 cases, based on how many children the target has

Case 1: Target has no children
	- just delete the target node, set parent POINTER (to that target node child) to nullptr

Case 2: Target has one child
	- easy, set target's parent to POINT to target's child, then delete target Node

Case 3: target has TWO children
	- let's assume we'd like to have minimal disruption on the structure of the tree
	- can we find another node that would be substitutable in place for the target node? call this the REPLACEMENT NODE
	- yes, there are guaranteed to be exactly TWO possible replacement nodes
		- biggest key down LEFT subtree
		- smallest key down RIGHT subtree
		- doesn't matter which one we pick. WLOG, let's pick largest key in left
	- can we swap the replacement node into the target's place?
	- what if the replacement node has two children?
	- answer: we are guaranteed that it WONT
		- all left descendants of the target are < target key
		- if largest key in left subtree has a right child, then there is something even bigger, so contradiction
		- so we know that the replacement node will have zero or one child

Therefore, let us try:
1. connect replacement parent to replacement's child (if it exists) to temporarily disconnect the replacement node from the subtree
2. then, insert the replacement node in place of the target node:
	- set replacement node's left / right pointers to values of target's left / right pointers, respectively
	- set target's parent to point to replacement NodeChunk
3. delete target node

A Variant Approach (arguably, conceptually simpler)
1. find replacement NodeChunk
2. copy the DATA VALUES of the replacement node (but not the pointers) into the target Node
	- if this is a BIG object, this might be expensive, but yolo for now
3. call BST_delete (target->left, target->key)
	- note that target_key is the key of replacement node, not of the original target
	- we are guaranteed that this will hit one of the first two cases and that the replacement node will be deleted

Complexity of Delete:
- with this implementation, you first find the target node, then dive down one of its subtrees to find the largest( / smallest) element in the left (/ right) subtree
- complexity is ______ // TODO

BSTs and Balancing
- we have shown just one approach (the simple, naive one) to inserting and deleting into a BST

Possible approaches:
	- ignore unbalanced trees (bad idea to ignore them)
	- ignore unbalances trees usually, periodically do a mass reblanacing
	- one each insertion, do a little work to make sure the tree is balanced (cs 240)
