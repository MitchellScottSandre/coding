Review: Binary Search Trees
	- binary tree, each node has up to two children
	- BST Property:  - all keys of all nodes in left subtree are < my key
				     - all keys of all nodes in right subtree are > my key
	- a BST is a sorted data container
	- Insertion, lookup, and deletion are all O(h) where h is the height of the tree
	- if tree is well balanced, then h is log(n)
=========================================================================================================
Today: FEB 9th

Here's a nice problem:
	- write a function that takes a plain old linked list (POLL) and reverse the order of the elements
	//copy down strategy TODO
	- look at code in file

Other problems:
- supposed you were asked to just read in a string values and print them in reverse order
	- recursion
	- linked list
	- use a vector
=========================================================================================================

What is the Mid Term Going to be Like?
	- T/F, short answer
	- what is the output from this program?
	- what a function that does XXX
	- what is wrong with this program?
	- do glance through the entire thing

=========================================================================================================

Abstract Data Type (ADT) vs Data Structure:
- ADT: should be understandable by looking only at the API
		- function signatures, pre post conditions of provided operations
		- stack, queue, dequeue, priority queue, sequence, dictionary (sorted or not)

- a Data Structure (DS) is more concrete:
	- it connotes some idea of underlying implementation / physical structure that may not be discernable from the API alone
	- data structures can be used to implement ADTs, tho DSs may be somewhat abstract themselves
	- vector, singly/doubly linked list, various trees, hash table

- the line between the two ideas is blurry!
	- C++ STL provides a vector but not a sequence

The SEQUENCE ADT:
- a sequence is a container of elements, indexed by a set of contiguous non-negative integers
- roughly the same idea as a vector
	- tho, vectors usually have the expectation of being implemented using a dynamic array (fast random access to elements, bust costly insertion)
- usually the first index is zero

	A Sequence: Common Operations:
		- insert(element, index)
		- append(element)
		- at(index)
		- remove(index)

	Insert:
		- inserts an element into the sequence at the specified position, moving all following elements "one slot to the right" conceptually, increasing the active size of the sequence
	//TODO fill more in

Implementing a Sequence:
					Insert:				Append				At:				Remove:
Array:				O(N)				O(1)				O(1)			O(N)
C++ Style Vector	O(N)				O(ACT)				O(1)			O(N)
Linked List			O(N)				O(1)				O(N)			O(N)

- Using an array implies a fixed maximum size
- insert/remove is really two operations: at plus add/remove element
- ACT == Amortized Constant Time, O(1) usually, sometimes O(N)

The C++ Vector (and List, and Dequeue)
- roughly, the C++ vector implements the sequence ADT
	- this vector adds a lot more functionality, too
	- the C__ standard REQUIRES that it be implemented as an array for fast accessing of elements, and allows amortized constant time on append (called push_back) as a reasonably trade off to achieve this
-C++ libraries LIST and DEQUEUE also implement the sequence ADT
	- list uses a vanilla doubly linked list
	- deque allows add/removes at the front AND back

- vector, deque, list support SIMILAR functionality, but they also have some differences
	_ ex: vector and deque support an at() method, but list does not
- also, vector, list, deque use iterators for insert/erase
- they differ in performance on some operations, pick the smart one

=========================================================================================================
The Dictionary ADT:
- a dictionary is a collection of ordered pairs of the form: (key, value)
	- the idea is a simple lookup table
	- adding (key, value) to dict means that dict[key] should return value afterwards
	- the value can be a string, object, set of values, etc
	- the dictionary may or may not be sorted by the key values
	- sometimes called a MAP, or ASSOCIATIVE array

	map<string, integer> uniNum;
	uniNum["Gilmour"] = 93;
	uniNum["Keon"] = 14;
	uniNum["Settler"] = 27;
	cout << uniNUm["Phaneuf"] << endl; // just says 0, NOT a run time error

	The dictionary ADT supports:
		- add(key, value)
		- overwrite(key, value)
		- lookup(key)
		- remove(key)

	Add: inserts the ordered pair (key, value) to the dictionary
		- error to add a pair if there is already an element defined on that key
	Overwrite: takes a key and a values, and overwrites the existing ...
	// TODO

	Remove: removes the ordered pair (key, dict[key]) from the dictionary
	Dictionaries MAY support a print operations
		- not assumd to be sorted by default
	- Dictionares may support
	// TODO

	Implementing a Dictionary:
							add		overwrite		lookup		remove
	Sorted Vector*			O(N)	O(logN)			O(log N)	O(n)
	Unosrted Vector*		O(1)	O(N)			O(N)		O(N)
	Sorted linked list		O(N)	O(N)			O(N)		O(N)
	Unsorted Linked List //TODO

The C++ Map:
- C++ provides a map data type that implements the idea of a dictionary
	- the map is an ordered(sorted) container, as are the related structures multimap, sets, etc
	// TODO

- Typical Declaration:
	map<T1, T2> m;
	- T1 is the key field type, it must support operator <, which must in turn be a STRICT WEAK ORDERING
		- anti reflexive, anti symmetric, transitive
		- its common to use strings or numbers as key, can use pointers
		- can use a user-defined class but you must ensure there is a reasonable operation< defined or provide an ordering FUNCTOR
	- T2 is the value field; can be anything

//TODO write code for map example from slides

Iterators:
//TODO
- up to the data structure to define them
