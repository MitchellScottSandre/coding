Introduction to Object Oriented Programming:

Let's Distinguish between 3 ideas:
	- Procedural Programming
		- procedures and variables
		- variables are created in main program and passed as parameters to procedures
		- can have structs
		- we create and manipulate instances of the struct type we have defined

	- Object-Based Programming: class has sub parts, variables, and operations
		- classes(fields + methods) + instances
		- structs have variable sub parts AND procedures that act on their sub-parts
		- subparts are called FIELDS or MEMBER variables
		- such procedures are called METHODS of the CLASS
		- basically OOP but just for one class, with no inheritance

	- Object-Oriented Programming:
		- classes/instances + inheritance/polymorphism + generics
		- classes can extend other classes
		- i.e. inheritance: class A (parent) serves as partial blueprint for class B (child)
		- child class B inherits all fields/methods of parent class A
		- child class B can add new fields/methods, and OVERRIDE the definitions of methods inherited from parent class A

		- sometimes you never make an instance of a [parent] class, you only make / use the child classes
		- EX: never make a monster class, but you can make a ORC or a TROLL (which are children or MONSTER class)

		- some classes can NEVER have any instances, they exist only to define common shapes of descendant classes
		- these are called abstract classes in many languages (Java)
		- but in C++, they are called Abstract Base Classes (ABC)

		Ex: vector <GameObject *> V;
		//game object could have Orc, Sword, Gold, Knife classes (all different, all children of GameObject)
		- cab create instances of related classes in a uniform manner
			- polymorphism


===========================================================================================================================================

	Review: Classes vs Structs
	- we are going to use classes for OO code and structs for non-OO code in cs138

	- private: only functions in that SAME class can access it
	- protected: descendants can view/access it
	- public: everyone can access it

	Nit: Using the default constructor (ctor)
		Balloon b;						//on stack
		Balloon rb ("red"); 			//on stack
		Balloon * pb = new Balloon;		//on heap
		Balloon * prb = new Balloon("red");//on heap
		we want these two statements to do the same thing:
		Flurble * f1 = new Flurble;
		Flurble * f2 = new Flurble();

	Class Declaration vs Definition:
		- the declaration of a class specifies its SHAPE
			- if it inherits from another class
			- what data subparts (fields) it has
			- what methods / constructors it supports and their signatures
			- if it defines a constructor
			- what the ACCESS RIGHTS are for its fields/methods with respect to other class
			- public or private or protected

		- the methods/constructors/destructors must still be defined, usually after the declaration

	Defining Methods:
		- need to provide implementations (definitions) of each method (including con and destructors) AFTER their declarations
		- Balloon::Balloon() means the Balloon method (constructor) of no args of the class Balloon
		- similarly, void Balloon::speak()
		- speak() by itself is not a procedure, its full name is and must be Balloon::speak()


	Things to Notice:
		- need to DECLARE ALL methods inside the class definition
		- instantiate a class just like a struct
			- object can be on the stack or on the heap, depending on how you instantiate it
			- use -> to call methods via a ptr; "." to call via an object
		- Stack reference parameter drops out of procs; it is IMPLICIT now!!!!!
			- passed by reference by default now :)


===========================================================================================================================================
	Constructors (ctors):
		Balloon:Balloon() : colour ("Lyons hunting tartan") {}
		Balloon:: Balloon(string colour) : colour (colour) {}

	A constructor (short hand: ctor) is a special kind of method that specifies one possible construction recipe for a new instance of the class
	- it has the same name as the class
	- it specifies what needs to be done to the sub parts to create a new instance
	- for any given instance, it is called EXACTLY once, at the beginning of its lifetime (no other constructor will be called again)
	- has no declared return typedef

	- there may be several constructors for a class, but they differ in the paramters they take
		- this is called OVERLOADING
		- these are alternative recipes for creation, but an outside client can call only one, for any given instance
	- often, but not always, we define at least the DEFAULT constructor
		- the one with NO arguments

THE DEFAULT C++ CONSTRUCTOR:
- constructor with no arguments
- if you define no constructors for your class/struct, then a default constructor will be defined for you by the compiler
- if you DO define one or more other ctors, then the compiler will NOT define the default one for you
===========================================================================================================================================

Inside a Method:
	- a method can be called by an instance of the class
	Balloon b;
	b.speak();
	- inside a method body, we can access subparts of the OBJECT by just referring to the fields or using the this->
	- this is a pointer that points to the OBJECTs variable


	Lookup Order:
	- is there a local variable of that name (defined inside the method)
	- is it a parameter?
	- is it a field of the defining class?
	- is it a field on an inheritance ancestor of the defining class?


Constructors: Java-style vs C++

	Balloon::Balloon(string colour){
		this->colour = colour;
	}

	- this is a common Java way, BUT in C++ we will use INITIALIZERS (cleaner??)

Constructors and Initializers:
	- C++ Advice: do as much as you can using initializers
	- the constructor body is only for the awkward initialization bits that you can't do via an initializer for some reason
	- any sub-part that is not set using an initializer will be constructed automatically using the default constructor for its type
	---> even if you reset the value in the body

	Format is:    partName(value)
	//no "this" needed for partName
	- Initializers are used for 2 purposes
		- calling constructor of parent class when using inheritance
		- initializing member variables

	- Balloon::Balloon() : colour("transparent") {}

	- Balloon::Balloon(string colour) : colour(colour) {}
