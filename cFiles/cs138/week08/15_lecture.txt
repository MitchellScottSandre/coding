Recall:

A Class Has:
	- data parts called fields / member variables
	- procedures that operate on the class, called methods
	- specifies methods for build recipes (constructors) and nuking (destructor)

A Class Specifies the access rights (public, protected, private) of its fields/methods with respect to external clients
- a method definition can "touch" the private internals of the object this points to, or another instance of the same class
- external clients can touch public parts (usually, methods) but not protected or private ones

- A Class is separated into a declaration (defining the class) and a definition, which consists of the implementations of the methods and allocation of static variables, if any
Ex:
Balloon::Balloon(string colour) : colour(colour){}
Balloon::~Balloon(){}

- A Constructor is a special kind of method that details how a new object is to be created, mostly by initializing its sub-parts
- use debug messages in the constructor and destructor

// This is C++ (Java style: legal but not preferred)
Balloon::Balloon (string colour) {
    this->colour = colour;
}
// This is C++ preferred style (using an initializer)
Balloon::Balloon (string colour) : colour(colour) {
	cerr << colour << " balloon is born. \n";
}

==========================================================================================================================

Balloon * b3;
Balloon b4 = (*b3); // "copy constructor" called, no output from the constructor is printed
delete b3; // a green balloon dies

Default constructor: does it make sense to have an unnamed child?
- if name field is declared as a const, we can't change it later!
- should balloon be implement as a sub object or Child or as a pointer?
	- if pointer, who creates the Balloon?
- should we pass in a Balloon or just a colour ( and create the Balloon ourselves )


More OO Terminology:
- a MEMBER VARIABLE (field) can be either
	- an INSTANCE VARIABLE (one per instance of the class), or
	- a CLASS/STATIC VARIABLE (one per class, full stop)
- a MEMBER METHOF can be either
	- an INSTANCE METHOD (operates on the THIS object, can call other instance methods directly without going through another object), or
	- a CLASS/STATIC METHOD
		- no implied "special" this object
		- can't call instance methods directly, needs to go through another object

Static Fields and Methods:
	- a new instance variable/field (the usual kind of variable in a class definition) is created for each object instance
		- and its value can change independently of the other instances over the lifespan of the object
		- an instance method (the usual kind) may look at or chance the instance variables of that object (as well as the static class variables!!!!)
	- a STATIC variable field (aka class variable) is different:
		- there is only one of them ever
		- a static method (aka class method) cannot access instance variables, except via object that get passed into them
		- generally, it is defined to manipulate static variables of the class

- if you use a copy constructor, Balloon fbcp = rb; the static variable number balloons doesn't change!

Copy Constructors:
	- a copy constructor is a constructor that takes a const ref to an existing object (of the same class) as its argument
	- it creates a copy (clone) of it as a new object
	- declaration of a copy constructor looks like this:
	C::C(const C & c) ; // C is class name

	- there is an implicit default copy constructor predefined for every class; it performs a memberwise copy construction
	- this is similar to the default implementation of operator=

	- sometimes, memberwise copy construction is not the appropriate recipe; then you need to define your own customized copy constructor
		- example scenario: if you have pointers to external object that may be shared
	- usual advice: Obey the RULE of THREE
		- if your class needs to override the default implementation for any of:
			1.the destructor
			2. the copy constructor
			3. operator=
			then it should provide explicit definitions for ALL THREE of them
	- this is because you probably have interesting (heap-based) sub parts that require special handling
	- however, we won't look at operator overloading (next year)

	class Balloon{
		public:
		...
		Balloon (const Balloon & b); // COPY constructor
		...
	};

	//only needed to make curNumBalloon count correct
	//the default implicit copy constructor does the colour copy

	Balloon::Balloon(const Balloon & b) : colour(b.colour){
		cout << colour << "balloon is cloned\n";
		curNumBalloons++;//increase the static variable appropriatly
	}

==================================================================================================

Garbage and Destructors:
	- amount of free storage in the heap (and stack space) are limited
	- what shall we do to heap-based variables that we no longer need?
		- the technical term of these variables is garbage?
	- many newer languages (Java, C#, Python) use automatic garbage collection, to reclaim dead variable storage
	C++: you made the mess, you clean it up
		- we define (at most one) destructor for each class; it gives a recipe for how to dispose of an object's subparts

Destructors: (shorthand: dtor)
- is a special method that specifies what needs to be "cleaned up" when an object dies
- like the nuke method we have created for previous data structures
- for a class Furble, a dtor is a special methods of no arguments
	Flurble::~Flurble() {
	cerr << "Flurble dies /n";
		//  do stuff to dfelete it as necessary
	}
- the destructor is called implicitly whenever one of the following happens:
1. an object's scope is exited (for an object is on the stack)
2. delete is called (for an object on the heap)
---> so we don't ever call Balloon::~Balloon() directly

- Destructor mostly says what happens to heap-based sub-parts when an object is destroyed
Really good idea: during initial development and debugging, put logging messages into ctor/dtor to help track what is going on, take them out to submit

Destructors and Responsibilities:
	- when an object dies (via deletes or having its scope end), all of its direct sub-objects will also die
	- we don't need to worry about those in the destructor
	- but, if the dying object has a pointer to an object on the heap (or, a vector of such pointers), you need to know who is (now? later?) going to kill off those objects
		- if we are the only ones that know about the object, just delete it in the body of destructor
		- if object is shared (others have pointers to the same object) we need a global agreement of some kind about who will kill it later

Design Questions:
How do we handle object sharing?
1. Don't share a stack-based object, instead, if you want to share it, create it on the heap and use a pointer
2. You need a clear understand of who "owns" the shared object (and who is responsible for deleting it in their destructor)
3. The "owner" class needs to define a protocol for changing ownership
	- you should probably do this with a method rather than justa public field
