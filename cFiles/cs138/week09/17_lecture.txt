Lecture 17: March 14th

The C++ Standard Library:
	- C++ has general purpose library of generic classes and functions called the Standard Template Library (STL)
	- Note: The C++ Standard Library == STL + some other stuff

	It contains:
	1. Generic CONTAINERS that take the element type as a parameter
		Ex: vector, list, deque, map, set, stack, queue, etc
	2. Kinds of ITERATORS that can navigate through the containers
	3. ALGORITHMS that take an iterator and perform an interesting operation on the elements in that range
		Ex: sort, random_shuffle, next_permutation


Iterators:
- the iterator is a fundamental design pattern of OOP
	- it's a functionality provided by (some) data structures to clients
	- it provides an abstract way of walking through some data structure one element at a time
	- start at beginning, advance one element at a time, until end;
	- CLIENTS DON'T NEED TO UNDERSTAND THE IMPLEMENTATION DETAILS

- in its simplest for, you are given:
	- a pointer to the first element of the collection
	- a pointer to just beyond the last element; reaching this value is the stopping criterion of the iteration
	- a way of advancing to the "next" element, usually operator++
	- to get the element itself, you have to dereference the iterator (which is a pointer)

So if f expects an iterator param...
	- usual usage pattern for for iterators in the STL:
		f (iter1, iter2, ...., ....,)
	- The implementer of function f will assume that:
		- iter1, iter2 are pointers
		- if I set p = iter1, then p++ will (magically) advance to point to the next element
		- (*p) should get me to the current element
		- I should stop when p == iter2 (and without doing any work using p at that value)

STL Containers provide iterators:
	- if c is a vector, deque, list, map, set, etc then
	c.begin() 		will always return a pointer to the first element
	c.end() 		will always return a pointer to "one beyond" the last element
	operator++  	will be defined so that it works appropriately on iterators

Usage:
	- in a for loop, you say
		for (..; vi != v.end(); vi++) with "..." being:
		vector<string>::const_iterator vi = v.begin();
		map(int, string):: iterator mi = mymap.begin();
		list<Figure * >::reverse_iterator li = scene.rbegin();

Kinds of Iterators:
	- plain old iterators take you forward thru a collection of data via ++
	- const iterators, where you promise not to change the collection/elements
		- in C++11, use cbegin() and cend() while using CONST
	- Bidirectional Iterators can go backwards by decrementing the iterator: vi--
	- Random Access Iterators: for navigating vectors, allow you to access random elements in no worse than ACT
		- if vi is an iterator in the middle of a vector, then vi[3] is the third element AFTER the current one

Random Access Iterators:
	- if vi is a random access iterator, then vi[3] gets you access to the third element after the one currently
	  pointed to by the iterator vi in no worse than amortized constant time (ACT)

Why Iterators are Awesome:
	- they provide a simple, natural interface for accessing container elements; they are implemented for us by STL container
	ex:
		vector<string>::const_iterator
		map<int, string>::iterator
		list<Figure *>::reverse_iterator
	- can also make your own iterators

C++11 and AUTO: (not on exam)
	vector<string> v; //
	for (auto vi=v.cbegin(); vi != v.cend(); vi++){

	}

Summary: Iterators:
	- suppose you have a "data container", call it v (vector, hash table, BST, etc) with complex internal structure that you
		wish to hide from external clients
	- an ITERATOR, call it vi, allows an external client to:
		- "walk through" the collection one element at a time and
		- perform an operation on each element
			Ex: print it, search for a special element, add an element's value to a running total, etc.
	- Three parts to a basic iterator:
		- "Where's the first element" 		--> 	vi = v.begin()
		- "How do I get to the next element?" --> 	vi++
		- "How do I know when I am done?" 	--> 	v.end()

	- all STL contains(vector, list, map, deck, etc) define at least iterator type
		- ex: vector<string>::iterator vi = v.begin();
		- you can define your own iterators for data containers you design
		- then you can use all the cool stuff in #include <algorithm>

	- all STL containers support iterator-based INSERT and ERASE methods
				HERE from START END
	ex: v.insert(iter1, iter2, iter3);
		- insert into container v at position iter1 a range of (external) elements whose BEGIN and END points are iter2, iter3
	ex: v.erase(iter1, iter2)
		- erases from v all elements in the range iter1 and iter2
3. Algorithms and Iterators:
- STL algoritms perform an abstract operation on a set of data
	- ex sort, random_shuffle, find, max_element, etc
	- they take iterators , and maybe additional arguments
	- they can be used on ANY DATA STRUCTURE (including ones we define ourselves) that can be walked through with an iterator
	- so not just STL Containers
	usual form of call:
		function(ter1, iter2, arg1, arg2... etc)
		Ex: if m is a list and you're looking for an element that matches val, say this:
		find(m.begin(), m.end(), val);

STL (C++98, 03) Containers			Some Useful Operations
ALL:								size, empty, insert, erase
vector<T>							[], at
									back, push_back, pop_back
deque<T>							[], at
									back, push_back, pop_back, front, push_front, pop_front
list<T>								back, push_back, pop_back, front, push_front, pop_front, sort, merge, reverse, splice

Some useful STL Algorithms:
	- find: locates the first element that matches a given object
	- count: counts the number of elements that matches a given object
	- for_each: applies a function to each element
	- remove:
	- replace:
	- sort:
	- unique: removes adjacent identical elements (only useful if container is sorted)
	- min_element, max_elment
	- nth_element
	- random_shuffle
	- next_permutation** //Can cycle through all N! permutations of an ordered container!


Polymorphism: Which Method Definition?

	- let's recall this snipper:
		for (int i = 0; i < v.size(); i++){
			//TODO
		}

Interesting:
P *f, * g;
f = new P;
g = new C;
f->m3();//illegal, f is a P*
g->m3();//illegal!!!! g is a C, BUT BUT g is a P* statically (it was statically created as P FIRST)

Review:
OBP and OOP Review:
	- inheritance naturally supports POLYMORPHISM, the ability to treat "similar" objects in a uniform way
		ex:
			vector<Figure *> v;
			//add stuff to v
			v.back()->draw();
	- note that polymorphism doesn't actually REQUIRE inheritance

OBP and OOP: Design Advice:
	- make data as private as possible
		- if you need to "share" within an inheritance hierarchy, try to keep parental variables PRIVATE;
		- use PROTECTED methods to share
		- whenever possible, let the parent class do all the housekeeping/direct manipulation of the member variables it introduces
	- design MATTERS
		- spend time thinking about your hierarchies, your public interfaces, who is responsible for what
		- don't be afraid to move things around during design

Polymorphism: Which method definition?
	recall:
	for (int i = 0; i < v.size(); i++){
		Figure * f = v.at(i);
		f->draw();//Circle? Square? Polymorphism!
	}

	- but, how does the object know which method definition to use?
	- let's draw a conceptual picture to explain
	- for simplicity, we assume that all methods are concrete and virtual

	- so, how does the system know which method implementation to use, since "correct" one can vary with the dynamic type?
	- if f is statically a Figure *, how does the compiler/run-time system know if f->draw() means Circle::draw() or Rectangle::draw()

	- when an instance method is called (via an object) and a stack frame is allocated for the method call, there is a THIS pointer in the stack fram pointing back to the calling object
	- so the run time knows which object's subparts are being changed inside the method body

Circle * c = new Circle("red", 0, 0, 5);
c->setRadius(25);//legal
Figure * f = c;
f->setColour("green");//legal
f->setRadius(33);//ILLEGAL

NOTE: it doesn't matter that f actually points to a Circle instance;
		--> since it was declared as a Figure * you can only treat is as a GENERIC FIGURE, and Figure does not support a setRadius method

Review: Static VS Dynamic TYPING:
	- every pointer has a static type, which is its DECLARED type
	- the static type does not change during program execution
	- every pointer also has a DYNAMIC type, which is the type of object that it is currently pointer to (or nullptr)
		- during execution, a pointer's dynamic type might change whenever it is assigned a new value
	- a pointer can be set to point to an object of ANY SUbCLASS of its declared type
