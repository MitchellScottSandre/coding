Review (Vector):
	- can think of as an expandable array that supports access with bounds checking via vector<T>::at()
	- vector elements must be stored contiguously according to the C++ standard, so pointer arithmetic will work and O(1) random access is guaranteed
	- append is AMORTIZED CONSTANT TIME; sometimes have to copy N elements

Review (Deque):
	- double ended queue, similar to vectors, but allow fast insertion/deletion at beginning/end
	- random access "fast", but NO GUARANTEE elements are stored contiguously
	- ... so pointer arithmetic won't work
	- operator[] and at() must be overloaded to work correctly
	- copies pointers instead of objects

New: List
	- is implemented as a (plain, old) doubly-linked list
	- all linked structures in STL are doubly linked, allowing iterator traversal up or down the structure
	- insertion/deletion: O(N) to get to the spot, O(1) once you get there to insert or delete

C++:11
- STD::array
	- functionally, it's a compile-time fixed-size vector
	- array<string. 12> monthName = {"jan", ..., "dec"};
	- can use at(), size(), length()
	- why not just use a vector?
		- best reason: strong typing: if you know the size should be fixed, enforce it via using an array
		- because arrays are SOMETIMES faster and more space-efficient (less overhead)
		- actual storage for VECTOR elements is always on the HEAP, whereas storage for ARRAY elements can be put on the run-time stack, since the size is known
	- NOTE:
		- accessing a vector element costs a pointer deference to the heap (pretty fast)
		- accessing an array element is an address calculation (even faster)
- STF::forward_list
	- singly-linked list
	- no push_back(), back(), size() methods

2. Container Adapters
	- usually a trivial wrapping of another sequence container data structure by a narrower interface with a specialized idea of how to add or remove elements
		- stack, queue, priority_queue
	- you CAN specifically in the constructor call which container you want to be used in the underlying implementation
	EX:
	stack:				 vector, deque*, list
	queue: 				 deque*, list
	priority_queue:		 vector*, deque

	* means default choice

3. Associative Containers
	- the ordering of the elements is based on a key value ( a piece of the element), NOT on the order of insertion
		- EX: employee records sorted by SIN or NAME etc, not by order
	- four predefined classes: [multi]set, and [multi] map

	- map is probably the most useful
		-it's also called an ASSOCIATIVE ARRAY in some other languages
	- we don't usually think of sets, etc, as being sorted (or sortable), but they must be to use these classes
		- most container operations (lookup, insert, delete) are O (logN)


	- typical declaration: map<T1, T2> m;
	- T1 is the KEY FIELD type, it must support oeprator<, which must in turn be a strict weak ordering
		- anti-reflexive, anti-symmetric, transitive
			- AR: A is not less than A
			- AS: A < B => b not less than or equal to A
			- TR: a < b, b < c, ==> a < c

		- it's common to use strings or numbers as a key, can use pointers
		- can use auser-defined class but you must ensure  there is a "reasonble" operator< defined or provided an ordering functor
	- T2 is the value field; can be anything

"The Same Key"
	- the library will use the following test for equality for elements in associative containers, EVEN IF YOU HAVE YOUR OWN DEFINITION OF OPERATOR==
		-  if (!(a<b) && !(b<a))
	- see example code

How are they implemented?

C++11 Unsorted Associative Arrays:

============================================================================================================
A Brief Look at Operator Overloading: Operators vs Methods
	- an OPERATOR is really just a kind of method/function that uses infix notation to call it
		EX: a = b + c; VS a = b.plus(c);
	- C++ allows you to redefine (overload) many existing basic operators to work as primitives on user-defined classes:
		=, +, -, *, /, %, ++, --, +=, *=, -=, ==, <, >, <=, !=, [], (), ->, new, delete, etc

	- Operator overloading is an undeniably useful
		- a ComplexNumber class could redefine + - * / = == appropriately
		- a Set class could define + to me Union, - to mean difference, etc

	- in hindsight it has been a MIXED BLESSING
		- can lead to code that can be hard to debug
		- lot of times WHEN to, and when NOT to, use operator overloading

	- practically speaking, an operator defined by a class is really just a METHOD that the compiler permits you to use with a different syntax
		- the compiler automatically converst your use of an overloaded operator into a method call; its a kind of SYNTACTIC SUGAR
		- if we define set::operator+ to mean union, then we can write "s1+s2" in our application ode, which the compiler will translate into "s1.operator+(s2)"

Make it a member function or not?
	- when you overload an operator (like ==) to work with objects of a user-defined class (like Money), you often have two deisng choices:
		1. make it a MEMBER FUNCTION of the class (with infix syntax)
			- for binary operators, the first argument is implied (the THIS object) and the second is a real parameter (often, a const ref)
		2. overload the GLOBAL DEFINITION of the operator (if it exists)
			- for binary operators, you have TWO parameters
			- class may need to declare it as friend if you need access to internals

	EX 1: ============================================================================
		// First option: make it a member function of Money
		class Money {
		public :
			Money ();
			Money (int dollars, int cents);
			bool operator== (const Money& m) const;
		private :
			int dollars, cents;
		};

		// Note const ref param and const method promise
		bool Money::operator== (const Money& m) const {
    		return m.dollars == this->dollars && m.cents == this->cents;
		}

	EX 2: ============================================================================
			// Preferred way: Overload the global def of operator==
		class Money {
			public :
				Money ();
				Money (int dollars, int cents);
				// Must be a friend, as there are no accessors for data
				friend bool operator==(const Money& m1, const Money& m2);
		  	private :
		    	int dollars, cents;
		};

		Money::Money() : dollars(0), cents(0) {}
		Money::Money(int dollars, int cents) : dollars(dollars), cents(cents) {}
		// Note both params are const refs

		bool operator== (const Money& m1, const Money& m2) {
    		return m1.dollars == m2.dollars && m1.cents == m2.cents;
		}


	- Rule of Thumb:
		- prefer NON-MEMBER, NON_FRIEND definitions when possible
		- rationale: this design improves encapsulation

	- Open (difficult question)
		- From a design perspective, is operator== truly global? or is it intrinsically related to Money, and so should be part of the class definition?
		- for example, + on Money feels like a good old addition, but + on strings (catentation), or sets (union) doesn't

Operator << Can Be Your Friend:
	- //TODO

Operator = can be a headache
	- we won't go into the details, but overload operator= has some real subtlety to it
		- especially if there are heap-baed suparts to your object
	- Cline's Rule of 3:
		- if a class provides a non-trivial definition for any of:
		1. copy constructor
		2. destructor
		3. operator=
		then it should provide a non-trivial definition for ALL THREE of them

Review: Overloading Operators
	- in C++, we can overload operators like +, -, *, /, ++, --, =, == etc
	- can overload as a global function or a member function
		- # of parameters different
		- global function MIGHT need to be a friend
		- some have to be done as a member function (operator=)
		- some as a global function (operator<<)
		- for others, it doesn't matter too much what approach you choose

	bool Balloon::operator== (const Balloon& b)
    bool operator==(const Balloon& b1, const Balloon &b2)

NOTE: if you define UNARY operators as member functions, REMEMBER that they take NO arguments
	- because they are automatically applying the operator to the *this
	const Money Money::operator-() const{
         return Money(-dollars, -cents);
	}
     const Money Money::operator+() const{ // or "return (*this);"
         return Money(dollars, cents);
	 }


StackOverflow.com: The Three Basic Rules of Operator Overloading in C++

1. Whenever the meaning of an operator is not obviously clear and undisputed, it should NOT be overloaded
	- instead, provide a function with a well-chosen name

2. Always stick to the operator's well-known semantics

3. Always provide all out of a set of RELATED operations

Design Patterns: a quick word

–  Template Method (already seen)
–  Adapter (already seen) and Façade
–  Iterator (already seen) and Visitor
–  Model-View-Controller (MVC) and Observer –  Abstract Factory and Factory Method
–  Composite, Object Pool, and Flyweight
–  Strategy (e.g., kinds of text jus-fiers)
–  Proxy

============================================================================================================================

Separate Compilation and A Quick Comparison of C++ vs Java

	1. edit flurble.cc
	2. compile: g++ flurble.cc
	3. run a.out

	- but for large programs (hundreds/thousands of classes!), it is more practical to separate out pieces of code into distinct COMPILATION units
		- with one file, you have to recompile everything from scratch each time you make a change
		- also block others from working in parallel
		- with multiple files, you have to recompile only the BITS that changed (plus the other bits that depend on them)
		- for big systems, this is a huge savings!
		- even with separate compilation building very large industrial systems from scratch can take a couple of days

Separate Compilation:
	- a fairly standard approach to separate compilation for C++:
		- for each class in your program, call it Foo
			- put the calss declaration (interface) into a file named Foo.h (including a guard #ifndef __FOO_H__)
			- put the implimentations of Foo's methods into a file named Foo.cc
			- put the main functional into a file named main.cc
		- there are two main phases to building a system
		1. COMPILE each of the compilation units (the .cc files)
			- g++ -c Foo.cc // produces a new file: Foo.oo
		2. LINK the object files (.o files) into a single executable
			- g++ -o myProgram *.o


g++ -c Foo.cc // what happens?
	1. first, the C/C++ preprocessor runs, performing #include, #define and checking #ifdef and #ifndef
		- this transforms the existing source code to new source code
		- try g++ -E Foo.c if you want to look at the results of this phase for fun

	2. then, any classes defined using templates are created; this is called TEMPLATE INSTANTIATION
		- ex: vector<string> is created from generic library definition vector<T>
		- this transforms the source code from the previous step to some internal representation (that is probably not easy to read, depending on the compiler)

	3. then, the results of the above are transformed into an object file, Foo.o
		- the whole process goes something like this:
			Source test ->tokens -> parse tree -> optimization -> object code

What does #include mean?
	- Each .cc file is usually compiled separately
		- it has to be able to see a declaration for any library and user-defined type / class that it uses, so it must include the appropriate.h files
		- the eventual .o file leaves an empty "slot" for the declared, but not yet defined, types, to be filled in when all of the .o files are linked together during the final stage of compilation

	- #include is simple textual inclusion!
		- the whole included file gets sucked up into the current file before being sent to the compiler
		- note that the ifndef guard prevents the rest of the file from being included more than once

	- each .cc file most include the corresponding .h file, using quotes
		-though there is usually no main.h file for main.cc
		EX: #include "Child.h" // in Child.cc

	- each .cc and .hfile must include all of the library entities that it references, using angle brackets
		EX: #include <string>

	- each .cc AND .h file must include the .h file of any user-defined class it references, using quotes

Compile Guard: ifndef
	- if not defined
	Problem: both main.cc and Child.h need to include Balloon.h, and main.cc needs to include Child.h
		- so Balloon.h will be included twice when we compile main.cc
		- without the ifndef guard, the compiler will complain when it sees the class declaration for Balloon for the second time

	- with the ifndef guard, the first time Balloon.h is included, the variable __BALLOON_H__ has not been seen before, so it is defined
	- the second time Balloon.h is included, the variable HAS been defined already, so the class declaration is skipped

Next Step: Linking
