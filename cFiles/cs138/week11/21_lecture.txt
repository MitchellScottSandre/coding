Unit Testing vs Integration Testing:

REVIEW: who depends on whom?
	#include:
		- if you use quotes, the compiler looks in the current directory
		- if you use brackets, it looks in the standard library locations
		- but where are the interface files for the standard library actually stored?
			- often a subdirectory of /usr/include

How are the implementations of library functions found?
	- well, for separately compiled libraries, once again the compiler just knows where to find them and how to link them to my program
	- for various technical reasons, classes that are defined using C++ templates MUST be fully defined inside the interface file
		//there's no .h/.cc split for templates
	- so, if you include vector, string, iostream, etc, you are actually including quite a bit of source code!
	- this means that each .cc file that includes vector has its own copy of the source code for vector etc pulled in by the preprocessor during compilation

Automatic Builds using Make
	- there is a powerful, old, Unix command line tool called make that can automate the build recipes
		- make is fairly smart about what needs to be rebuilt after changes occur
		- you will need to give it a recipe for building your system in a file called Makefile
		- also ANT, MAVEN, SCONS, etc

FYI: Building Java Programs
	- in Java, we don't separate out interface from implementation, it all goes into one big .java file
	- usually we put one major class in each .java file

	- there is no preprocessor or template instantiation phase
		so no #include, etc,

	- usually, for a given progra comprising many classes, there is one class that has the "real" main program in it
	- but any class can have its own main program, too
	- this allows each individual class to contain unit tests for that class (tho its also common to define separate testing classes in parallel)

	- a Java source file, call it Foo.java, can be compiled separately
		javac Foo.java
		- this will automatically trigger the compilation (if needed) of all other classes that Foo uses or depends on
		- javac is smart about not recompiling files that haven't changed since last time

	- separate compilation produces a file called Foo.class
		if Foo has a main function, you can run it at the command line:
		java Foo

	- [referring to examples Child and Balloon] here, both ballon.java and child.java have main function
	- that means both classes can be run at the command line via "java"
	- it's common to create test suites for each source code class; this is called unit testing
C++ vs Java: A Little History

	C++: C with classes, first C-like OO language
		- [Objective C was the second]
		- relies mainly on clever programmers for good performance
	Java: Simpler, cleaner, portable C++
		- C++ offers: faster, unsafe way vs slower, safe way
		- Java offers only slower ,safer way (EG: checks pointer validity, array bounds)
		- relies mainly on clever run-time system (JVM) implementation for good performance (JIT compilation)
	C#: Java, with hindsight
		- As with Java, "safer" way only: no safe or fast choices
		- As with Java, the run-time system (CLR) does a lot of the heavy lifting

C++ vs Java: Commonalities
	- C-like syntax
	- support for basic types: ints, floats, bools, etc
	- similar memory model
	- strong support for OOP, generics
	- strong exception handling
	- strong library support


Source Model: C++ vs Java

	C++:
		- compile anywhere
		- compiles to native, platform-dependent code
	Java:
		- compile once, run anywhere
		- compiles to "Java byte code", a universal low-level object code
		- needs a JVM to fun


C++ vs Java: Differences
	- look at notes on slides
==================================================================================================================================

A few Notes on Computer History, C++, and Other Programming Languages:

	1940s/50s:
		- programming is done directly in machine language and (later), assembly language
	1950s:
		- First "high level languages": FORTRAN, COBOL, and LISP
		- are all still in common use!
		- FORTRAN designed for scientific calculations, LISP (Scheme, Racket) for CS, COBOL for business (data processing)

	1960s:
		- first attempt to define clean, abstract imperative languages
		- first object-oriented language: Simula67(for simulations)

- Machine and Assembly Language
	- CPUs have set of very low level instructions that they can execute directly
		- load/store contents of memory address to/from register
		- perform arithmetic operations on values in registers
		- skip to another place in the current program
	- each family of CPUs have their own instruction set (machine language)
	- assembly language is a slightly easier-to-use abstraction of a given machine language

Assembly Language:
	- Programming directly in assembly language is possible, but very very hard
	- we prefer High-Level Languages like C/C++, Java, Python, etc
	- then use compiler or interpreter to automatically generate machine language instead
		- Java and C# use a technique called Virtual Machine that makes it easier to write code to be used on any platform

=============================================LANGUAGES================================================
1950s:
FORTRAN == (Mathematical) FORMula TRANslation
	- first "high-level programming language"
	- John Backus, 1957, IBM
	- procedural/imperative style, DO-loops, IF statement, arithmetic, ints, floats, arrays
	- no {} blocks, use GOTOs instead

COBOL == Common Business-Oriented Language
	- Admiral Grace Hopper (US NAVY) 1959
	- designed for data processing
		- manipulating HR data, computing payrolls, etc
		- banks, insurance companies, government agencies all have LOTS of old COBOL systems even today
	- language features:
		- procedural/imperative style: "structs", GOTOs (make logic hard to follow), code reals like (awkward, verbose) prose
		- MOVE X TO Y; ADD Y TO X GIVING z; if X GREATER THAN Y ...

LISP: (SCHEME/Racket)
	- John McCarthy, MIT, 1958
	- simple, elegant, designed by a mathematician
	- functional programming: you provide a set of functions definitions and then apply the functions to arguments
	- NO LOOPS; recursion instead

1970s:
	- C and Unix co-developed at AT&T Bell Labs
		- Ritchie, Thompson, Kernighan
	- C is a breakthrough! so is UNIX
		- can write coe efficiently, fairly portable, very powerful
	- DIY memory management, lots of insecure code and errors

	- late 1970s, on the first "micros"
		- BASIC
		- small, simple procedural language
		- easy to learn
		- cheack to run on small computers

1980s:
	- C++ AT&T Bell Labs
	- powerful and efficient OO language, but very complicated

1990s:
	(early)
	- Java at Sun Microsystems
	- Idea: an OO language that will work everywhere
	- take the best ideas of C++ but remove complicated and error-prone features
	- portability achieved through a virtual machine

	(late)
	- Microsoft .NET and C#
		- tried to do the same thing as Java, but with several years of hindsight and experience using/learning from java


=============================================LANGUAGES================================================

Industrial Programming Today:
	- Old Days: Design a monolithic system to run on top of a desired OS on particular hardware
		- porting to a new development platform takes a lot of work!

	- these days: design a piece of a component that interacts with a bunch of other services, platforms, and peer components across various networks and the cloud
		- underlying OS is rather irrelevant
		- web services, rich frameworks, scripting languages
		- interaction is assumed via APIs, services like JSON, XML

"Scripting Languages"
	- JavaScript, Pythong, PHP, Scala, Ruby...
	- Old Days:
		- monolithic programs did the heavy lifting
		- co-ordination used shell scrips (Bash) to move files around, start processes, etc

	- These days:
		- scripting languages are much more powerful, support OO and modules
		- easier to create medium sized programs
		- typically dynamically-typed, can be hard to debug

We Did C++ because:
	- C/C++/Java memory model dominates all others in the industry
	- C++ supports full OOB and OOP
	- lots of interesting language design features, points, templates, multiple inheritance

A Word About C++ Compilers:
	- g++ is an open source C++ compiler from the GCC project, mature, high quality, supports c++11
	- clang++ is another one, overtaking g++
	- faster to compile, produce faster object code, gives nicer error messages

Compiler Architecture 101:
	- common to design a compiler with an explicit front and back end
	- front end: translates source code into a set of intermediate data structures that are largely independent of both the source language (C++) and the target platform (linux, max, etc)
	- back end: takes the intermediate data structures and generates binary executables that are tied to target the OS
